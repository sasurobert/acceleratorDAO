# Active Yield Strategy Standard (AY-SS)
**Technical Specification for Canonical Vaults**

## 1. Overview
To ensure all "Canonical Vaults" (from Perps to Lending) are composable with the Accelerator DAO's boost engine, they must adhere to the **Active Yield Strategy Standard (AY-SS)**. This standard allows the DAO to programmatically read productivity metrics and inject boost rewards.

## 2. Core Philosophy
*   **Tokenized Positions**: Strategies must issue **Dynamic SFTs (Semi-Fungible Tokens)** or **NFTs** representing the user's deposit. This enables composability (e.g., using the position as collateral elsewhere).
*   **Claimable Rewards**: Boost rewards (EGLD) accumulate in the contract and are claimable by the SFT holder. They are *not* auto-compounded into the position.
*   **On-Chain Registry**: A decentralized registry governs which strategies are eligible for boosts.

## 3. Smart Contract Interface (Rust / multiversx-sc)
Every Strategy Contract must implement the `ActiveYieldStrategyModule` trait.

### 3.1. View Functions (Read-Only)

```rust
#[multiversx_sc::module]
pub trait ActiveYieldStrategyModule {
    /// Returns the total amount of assets managed by the strategy.
    /// Used for TVL calculation.
    #[view(getTotalValueLocked)]
    fn get_total_value_locked(&self) -> BigUint;

    /// Returns the cumulative fees generated by the strategy since inception.
    /// Represents the "Productivity Metric". The DAO Oracle reads the delta.
    /// Format: EGLD Value (18 decimals).
    #[view(getCumulativeProductivity)]
    fn get_cumulative_productivity(&self) -> BigUint;

    /// Returns the SFT/NFT Token Identifier used for positions.
    #[view(getStrategyTokenId)]
    fn get_strategy_token_id(&self) -> TokenIdentifier;

    /// Estimates claimable rewards for a given SFT nonce/balance.
    /// Useful for UI display.
    #[view(getClaimableBoost)]
    fn get_claimable_boost(&self, token_nonce: u64, amount: BigUint) -> BigUint;
}
```

### 3.2. Write Functions (Interaction)

```rust
pub trait ActiveYieldStrategyActions {
    /// 1. Enter Strategy
    /// User sends Assets (e.g., USDC, EGLD) -> Contract.
    /// Contract mints and sends a "Strategy SFT" to the user.
    #[payable("*")]
    #[endpoint(deposit)]
    fn deposit(&self);

    /// 2. Claim Rewards
    /// User sends "Strategy SFT" -> Contract.
    /// Contract calculates rewards based on SFT data/time.
    /// Contract sends Rewards (EGLD) + Returns the SFT to user.
    /// Note: If the SFT is 'Dynamic', the contract might update its attributes (e.g. reward debt).
    #[payable("*")]
    #[endpoint(claimRewards)]
    fn claim_rewards(&self);

    /// 3. Inject Boost (DAO Only)
    /// Called by the Accelerator DAO (or Keeper) to deposit the Boost EGLD.
    /// This increases the global reward index/accumulator.
    #[payable("EGLD")]
    #[endpoint(injectBoost)]
    fn inject_boost(&self);
}
```

## 4. The Architecture

### 4.1. The On-Chain Registry
A dedicated contract `AcceleratorRegistry` manages the whitelist.
*   `submitStrategy(address)`: Builder submits their deployed contract.
*   `approveStrategy(address)`: DAO Governance (MultiSig) approves it.
*   `isWhitelisted(address) -> bool`: Oracle checks this before reading productivity.

### 4.2. Reward Logic (The "Option A" Flow)
1.  **Injection**: DAO sends 10,000 EGLD to the Strategy.
2.  **Accounting**: The Strategy updates a global `rewardPerShare` accumulator.
    *   `rewardPerShare += injectedAmount / totalShares`
3.  **Claiming**: When a user calls `claimRewards` with their SFT:
    *   `pending = (userShares * rewardPerShare) - userRewardDebt`.
    *   User receives `pending` EGLD.
    *   The SFT's `userRewardDebt` is updated (if stored in metadata) or tracked in contract storage mapping.

### 4.3. Dynamic SFTs
*   The Strategy SFT should use MultiversX **Meta-ESDT** or **Dynamic NFT** standards.
*   **Metadata**: Can store the `entry_timestamp` or `reward_debt` to enable precise calculations without heavy contract storage.

## 5. Security Requirements
*   **Immutable Productivity**: `getCumulativeProductivity` must be strictly tied to fee generation events.
*   **Non-Custodial**: The DAO never touches the user's underlying assets (`USDC`, `lsEGLD`).
*   **Audit**: Strategies must be audited to ensure the `injectBoost` function cannot be drained by non-holders.

## 6. Implementation Checklist
1.  Deploy `AcceleratorRegistry`.
2.  Deploy Reference Implementation (The "Genesis Magnet" Pool).
3.  Verify Oracle integration with `getCumulativeProductivity`.

## 7. Collateralization Standards (Lending Integration)
If a Strategy SFT/LP is whitelisted as collateral in a Lending Protocol, the following **Strict Mandates** apply:

1.  **Oracle Mandate (TWAP)**: The Lending Protocol MUST use a **Time-Weighted Average Price (TWAP)** (Min 30 minutes) or a "Fair LP Price" invariant for valuation. Spot Price usage is strictly prohibited to prevent Flash-Crash attacks.
2.  **Isolation Mode**: Strategy Tokens must be **Isolated Collateral** initially. Users borrowing against them cannot cross-margin with other volatile assets to contain risk.
3.  **Conservative LTV**: Maximum Loan-To-Value (LTV) is capped at **60%** to buffer against Impermanent Loss volatility spirals.

